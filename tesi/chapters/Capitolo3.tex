\chapter{Tecnologie aziendali utilizzate}
\label{cap:chapter3}

Questo capitolo si propone di fornire una panoramica generale sulle tecnologie e i software utilizzati nell'architettura del progetto, nonché quelli adoperati dall'azienda stessa. L'obiettivo è quello di comprendere più approfonditamente le scelte progettuali adottate durante il percorso lavorativo del candidato.

\subsection{Microservizi e Docker}

La piattaforma, che prende l'acronimo di \textit{BMS} (\textit{Bridge Management System}) è stata sviluppata come un'applicazione Web moderna, seguendo un'architettura a microservizi che favorisce la modularità e la scalabilità del sistema. Questa scelta architetturale è stata preferita rispetto alle tradizionali applicazioni monolitiche, in quanto ha permesso di separare i vari servizi, semplificandone la gestione e consentendo una maggiore flessibilità nell'implementazione di nuove funzionalità.
\\Questo approccio è molto comune per le applicazioni di grandi dimensioni, poiché ogni microservizio può essere sviluppato e mantenuto in modo indipendente dagli altri, utilizzando, se necessario, anche linguaggi di programmazione differenti. Tale sistema permette agli sviluppatori di concentrarsi su ogni funzionalità singolarmente, rimanendo isolati da tutto il resto dell'applicazione. Inoltre, grazie alla possibilità di utilizzare linguaggi differenti, è possibile scegliere la soluzione più adatta in base alla funzionalità che deve essere implementata. Quest'architettura favorisce la scalabilità orizzontale, ovvero la possibilità di aggiungere o rimuovere istanze di singoli microservizi in base alle esigenze di carico, senza dover scalare l'intera applicazione. Dunque, rende più efficiente l'utilizzo delle risorse e consente di gestire picchi di traffico in modo più efficace.
\\Per gestire questo tipo di architettura, si è scelto di utilizzare Docker, ovvero una piattaforma che consente di creare e gestire container, cioè ambienti isolati che contengono tutte le risorse necessarie per eseguire un'applicazione.
Ogni servizio viene dunque "containerizzato", ovvero viene isolato in un ambiente autonomo con tutte le risorse e le dipendenze necessarie per il suo funzionamento. La containerizzazione attraverso Docker rende notevolmente più semplice lo sviluppo dell'applicazione, in quanto gli sviluppatori, lavorando sullo stesso container, possiedono tutti lo stesso ambiente di sviluppo: la stessa versione delle dipendenze, librerie e del linguaggio di programmazione. Inoltre, una volta che l'applicazione è pronta per il deployment (cioè pronta per essere messa in produzione), viene eseguita su server in un ambiente ancora containerizzato. Così facendo, si ha la garanzia che l'applicazione continui a funzionare come quando è stata sviluppata, e, se necessario, è possibile scalarla orizzontalmente attraverso l'uso di servizi Cloud come Amazon AWS.

\subsection{WebServer e Reverse Proxy}

È stato impiegato un WebServer che, tra le altre cose, ha svolto il ruolo di un Reverse Proxy, permettendo di semplificare la gestione del traffico HTTP diretto verso i container Docker. Un WebServer è un software che riceve tutte le richieste HTTP inviate da client (per esempio browser) e che alla fine fornirà loro delle risposte, solitamente sotto forma di dati o pagine web.
\\Comportandosi da reverse proxy, il WebServer reinstrada le richieste ricevute verso il microservizio appropriato, mascherando ai client la pluralità di servizi esistenti. Una volta ricevuta la risposta dal microservizio, la trasmette al client che ne aveva fatto richiesta. Nel dettaglio è stato utilizzato Caddy come WebServer, poiché offre delle semplici modalità di configurazione, tramite la stesura del file "Caddyfile", fornito dal software stesso. 
\\Il suo uso principale è stato quello di permettere ai client di contattare i servizi containerizzati tramite un dominio, anziché un indirizzo ip con una porta associata: ad esempio, invece di contattare il container che ha al suo interno il servizio di rest API all'indirizzo \textit{127.0.0.1:8080}, è possibile contattarlo tramite il dominio \textit{bms.local.gkops.net/api/}. Grazie a questa modalità, è possibile simulare un ambiente di produzione, nel quale tutti i servizi vengono contattati su un dominio apposito tramite protocollo HTTPS. Quest'ultimo dettaglio è possibile grazie a Caddy che permette di installare certificati TLS sui domini da lui creati. È stato utilizzato Let's Encrypt come Certification Authority.
\\Inoltre, se necessario, tramite Caddy è possibile eseguire load balancing tra i microservizi, il quale consente di distribuire il carico tra più istanze del servizio per garantire una migliore scalabilità e affidabilità del sistema.
\\Infine, l'utilizzo di Caddy è essenziale per effettuare meccanismi di caching tra le richieste HTTP inviate dai client ai microservizi: nel caso in cui venga posta la medesima richiesta, il WebServer non richiederà nuovamente al il microservizio la risposta, bensì risponderà direttamente al client.

\subsection{Front-end e Back-end}

Per quanto concerne le tecnologie impiegate nello sviluppo dell'interfaccia grafica della piattaforma, è stato selezionato \textit{Angular}, un framework JavaScript moderno e robusto, caratterizzato da una struttura modulare che offre una vasta gamma di librerie. Queste caratteristiche lo rendono particolarmente adatto per la creazione di interfacce utente dinamiche e complesse, richieste proprio da progetti di questo tipo.
\\Questi framework presentano un'architettura basata su componenti, cioè permettono di costruire l'interfaccia grafica attraverso l'uso di componenti che possono essere riutilizzati. Questo consente di avere una programmazione modulare, in cui ogni componente HTML viene visto come un modulo a sé stante, che può essere importato e riutilizzato su pagine web differenti. Questo rende il codice più organizzato, facile da comprendere e da mantenere, specialmente all'aumentare delle dimensioni e della complessità dell'applicazione.
\\Lato back-end, invece, è stato adottato l'utilizzo di un framework ad alto livello come .NET, il quale offre un insieme di funzionalità e strumenti per lo sviluppo di applicazioni complesse e scalabili.
\\L'adozione di Angular e .NET come principali framework di sviluppo hanno consentito agli sviluppatori di seguire un pattern unificato attraverso una varietà di progetti. Questa scelta ha ridotto la confusione e ha garantito una maggiore coerenza nelle implementazioni, assicurando che tutti i software sviluppati seguissero gli stessi standard e convenzioni. Si tratta di un aspetto cruciale in contesti aziendali con molti progetti in corso, in quanto si facilita la gestione e la manutenzione dell'intero insieme di software.
\\Infine, nella comunicazione tra front-end e back-end della piattaforma, è stato adottato il paradigma delle \textit{Rest API}, che rappresenta uno standard per lo scambio di dati tra client e server su protocollo HTTP. Più specificamente, le API sono esposte tramite Swagger UI, consentendo al front-end di interagire con esse in modo intuitivo e documentato. Il protocollo utilizzato per definire le specifiche delle API rispecchia lo standard di OpenAPI 3 (OAS3), garantendo una chiara e precisa descrizione delle operazioni e dei dati scambiati tra front-end e back-end.

%\subsection{Reactive Programming e Angular}

%Si è poi proseguito con lo studio della libreria RxJS, fondamentale per l'uso di Angular, in quanto è parte integrante dello stesso.
%Tale libreria viene utilizzata internamente da Angular per gestire numerose operazioni asincrone attraverso l'uso di Stream, adottando il paradigma di "Reactive Programming" invece che "Event Driven".
%\\Nel paradigma a eventi, viene scritto del codice per gestire un evento quando questo si verifica. In genere si definisce una funzione, nota come callback, che viene registrata su un certo evento. Quando tale evento si verifica, come ad esempio un click del mouse su un pulsante, la funzione registrata viene invocata per gestire l'evento di click.
%Nell'approccio reattivo, invece, viene scritto del codice per gestire uno Stream di dati che rappresenta una sequenza continua di eventi. Ad esempio, invece di gestire il singolo click del mouse, viene creato uno Stream che rappresenta i click che avvengono del tempo. Tale Stream può essere manipolato, filtrato o trasformato utilizzando degli operatori.
%\\Angular utilizza RxJS per adottare quest'ultimo tipo di paradigma, facendo uso di tre elementi interdipendenti: l'Observable, gli Operator e gli Observer.
%\\L'Observable è colui che fornisce i dati sullo Stream ed è colui che è oggetto dell'osservazione. Durante il fornimento dei dati, che avviene in maniera continua nel tempo, gli Operator si occupano di manipolarli. Gli Operator sono delle operazioni che permettono la manipolazione dei dati sullo Stream in maniera asincrona. Le operazioni più note sono la mappatura, il filtraggio, la combinazione e la trasformazione. L'Observer si trova alla fine della catena e si occupa di utilizzare il risultato dei dati elaborati.
%\\Angular utilizza internamente gli Observable a basso livello per gestire i suoi componenti, mentre ne espone un'interfaccia semplificata ad alto livello per l'utilizzo da parte degli sviluppatori. Ad esempio, il routing delle pagine web e il modulo del form di input fanno uso degli Observable per monitorare e rispondere agli eventi di input dell'utente.